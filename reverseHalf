/** Write a method reverseHalf that reverses the order of half of the elements of a Queue of integers. 
Your method should reverse the order of all the elements in odd-numbered positions (position 1, 3, 5, etc.) 
assuming that the first value in the queue has position 0. For example, if the queue originally stores this sequence of numbers when the method is called:

index: 0  1  2  3  4  5   6   7
front [1, 8, 7, 2, 9, 18, 12, 0] back
- it should store the following values after the method finishes executing:

index: 0  1  2  3   4  5  6   7
front [1, 0, 7, 18, 9, 2, 12, 8] back
Notice that numbers in even positions (positions 0, 2, 4, 6) have not moved. 
That sub-sequence of numbers is still: (1, 7, 9, 12). But notice that the numbers 
in odd positions (positions 1, 3, 5, 7) are now in reverse order relative to the original. 
In other words, the original sub-sequence: (8, 2, 18, 0) - has become: (0, 18, 2, 8). You may use a single stack as auxiliary storage.
**/

//First attempt,this only passed 4/8 tests. i also tried playing with an interator to add the values of the auxilalry stack back to the queue, 
but that is not possible because of concurrent modification exception.//

public static void reverseHalf(Queue<Integer> q) {
	int count = 0;
	Stack<Integer> storage = new Stack<Integer>();
	Iterator<Integer> itr = q.iterator();
	int currIndex = 0;
	
	
	while(itr.hasNext()) {
		
	
		count++;
		currIndex = itr.next();
		
		
		if(count%2 == 0) {
			storage.push(currIndex);
			itr.remove();
			
			
		}
	
	}



	//System.out.println("NUM of NUMs" + count);
System.out.println("STORAGE" + storage);
System.out.println("Queue" + q);
if(!q.isEmpty()) {
	
	int peekNum = q.remove();
	
	
	q.add(peekNum);
	}

	
	while(!storage.isEmpty()) {
		
		q.add(storage.pop());
		q.add(q.remove());
		
	}
	
	
	System.out.println("Reversed Half : " + q);
	
	
	//while(!storage.isEmpty()) {
		
	//	while()
	//}
	
	
	
	/**

	Iterator<Integer> itr2 = q.iterator();
	
	
	int counter = 0;
	while(itr.hasNext()) {
		counter++;
		
		if(counter % 2 == 1) {
			itr.remove();
		}
	}
	

	**/

//Second attempt passed 8/8 tests. Got completely stuck for a couple of day, decided to find a way using TWO Stacks as auxillary storage. 
After it worked with 2 backup storages, I had to find a way to use my logic from using 2 backup storages and condense it into one auxillary storage.
Ended up working. However, was left with an error because sometimes the queue was removing and adding back too many numbers. I had to store the size of the
queue -1 into a variable, and then use a for loop to add and remove elements for queue while continiuosly decrementing the size of the queue.

public static void reverseHalf(Queue<Integer> q) {
	int count = 0;
	Stack<Integer> storage = new Stack<Integer>();
	Iterator<Integer> itr = q.iterator();
	int currIndex = 0;
	
	
	while(itr.hasNext()) {
		
	
		count++;
		currIndex = itr.next();
		
		
		if(count%2 == 0) {
			storage.push(currIndex);
			itr.remove();
			
			
		}
	
	}



	//System.out.println("NUM of NUMs" + count);
System.out.println("STORAGE" + storage);
System.out.println("Queue" + q);
if(!q.isEmpty()) {
	
	int peekNum = q.remove();
	
	
	q.add(peekNum);
	}

	int sizer = q.size() - 1;
	while(!storage.isEmpty()) {
		
		q.add(storage.pop());
		
		if(sizer != 0) {
		q.add(q.remove());
		}
		sizer--;
		
	}
	
	
	System.out.println("Reversed Half : " + q);
	
	
	//while(!storage.isEmpty()) {
		
	//	while()
	//}
	
	
	
	/**

	Iterator<Integer> itr2 = q.iterator();
	
	
	int counter = 0;
	while(itr.hasNext()) {
		counter++;
		
		if(counter % 2 == 1) {
			itr.remove();
		}
	}
	

	**/

	
	
	
}
	
	
	
}
